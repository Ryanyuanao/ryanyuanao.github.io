# javascript忍者秘籍

## 第三章
1. 立即执行函数（IIFE）的几种写法：
```
// 1. 常用写法
(function() {})()

// 2. 不常用
(function() {}())

// 3. 在javascript库中会常见到。一元操作符也能告知js引擎处理的是表达式
+function() {}()
-function() {}()
!function() {}()
~function() {}()
```
2. IIFE 加上`()`因为JavaScript解释器必须能够轻易区分函数声明和函数表达式的区别。如果去掉包裹的`()`，JavaScript开始解析时便会结束。因为函数需要函数名，没有函数名会报错。加上`()`指明正在处理一个函数表达式而不是语句。


## 第四章
1. 参数`this`表示被调用函数的上下文对象，而`arguments`参数表示函数表用过程中传递的所有参数。
2. `arguments`是一个带有`length`属性的**类数组**结构。表示函数的**形参**。
3. 当函数以 *函数调用* 的方式调用的时候，非严格模式下，`this`指向`window`，严格模式下，`this`指向`undefined`。
4. **函数和方法**的命名通常以**描述其行为**的动词开头，且第一个字母小写。而构造函数则通常以描述构造对象的名词命名，并以大写字母开头。
5. 使用`call`和`applay`可以显示指定任何对象作为函数的上下文。
- call 接收 一个作为函数上下文的对象 和 **一个函数列表**
- allpay 接收 一个函数上下文的对象 和 **一个数组**

6. applay和call的功能类似，问题是在二者中如何选择？**应该选择任意可以精简代码的方法**。如果一组无关的参数值，则选择call。若已有参数是数组类型，则可以选择applay。
7. 在使用**箭头函数**的时候，不会隐式传递this参数，而是从定义时的函数继承上下文。
8. 函数可以通过bind方法创建新函数。无论使用哪种方法调用，bind方法创建的新函数与原始函数的函数体相同，**新函数被绑定到指定的对象上**。


## 第五章
1. 每个JavaScript程序只创建一个全局执行上下文，并从全局执行上下文开始执行。当遇到函数时，会停止当作用域，然后把函数推入栈顶，并执行该函数。当该函数执行完成，会从栈顶弹出，然后继续执行上一函数上下文。

每个函数执行完之后，对应的函数上下文从执行上下文栈顶部弹出。
2. 当执行一个语句时，JavaScript引擎首先会检查当前执行上下文，如果能够找到，则查找完成，如果查找不到，则会向上一层的外部环境进行查找，如此往复直到查找全局环境。**引擎查找不会向内部进行查找，也就是说内部可以访问外部变量，外部不能访问内部**。
3. `const`用于提供一个不变的变量。指向一个固定的值，使用`MAX_COUNT`来表示对应的值，比直接表示一个值更语义化。
4. `const`虽然不能直接修改值，但是可以对已有的值进行修改。比如说`Object/Array`。
5. 全局静态变量通常使用大写表示：`const GLOBAL = 'name'`
6. 通过函数声明的方式`function test(){}`可以在声明之前进行调用。因为在当前词法环境创建时已在其他代码执行之前注册了函数标识符。所以，在执行其他函数调用之前，`test`函数已经存在。

而通过函数表达式`let test = function() {}`或箭头函数`let test = () => {}`的方式声明函数，则不可以先行调用。因为它们是在程序的执行过程中执行定义的。


## 第六章
1. 生成器函数（generator）可以使函数挂起和执行。使用方式为在`function`后面添加一个`*`，然后使用`yield`来对值进行挂起操作。
2. 使用`next`可以执行`yield`语句。`yield`语句默认返回`undefined`，所以`let a = yield 3` ，执行next后， a 为 undefined，如果给`next()`传入参数后，`yield`就会返回传入的参数。
3. 第一次调用next传入参数无效，因为next方法的参数表示**上一条yield语句的返回值**，所以第一次调用无效。


## 第七章
1. `Object.setPrototypeOf(obj, proptotype)`方法设置对象的原型。
2. 可以使用`XXX.prototype = new XXX()`来实现继承，但是还需要指会原来的`constructor`。ES6通过使用`extend super`来实现继承，而且不需要那么麻烦的指定。


## 第八章
1. 通过在属性名前面加上`get`关键字定义`getter`。`getter`不接收任何参数。
2. 通过在属性名前面加上`set`关键字定义`setter`。
3. 在对象中使用`getter / setter`
```
let person = {
    _name: 'a',
    
    get getName() {
        return this._name
    },
    
    set setName(value) {
        this._name = value
    }
}
```
4. 使用`Object.defineProperty`方法可以实现私有属性
```
function Test() {
    let _count = 0
    
    Object.defineProperty(this, 'count', {
        get: () => {
            return _count
        },
        
        set: value => {
            _count = value
        }
    })
}
```
5. `proxy`使用代理。
```javascript
function proxyF(obj) {
  return new Proxy(obj, {
    get: (target, key) => {
      return key in target ? target[key] : (console.error(`${key} is not defined`))
    },
    set: (target, key, value) => {
      target[key] = value
    }
    })
  }
  
  let person = {
      name: 'a'
  }
  
  person = proxyF(person)
```

6. **使用代理会带来额外的性能消耗**，所以，可以在对性能不敏感的程序里面使用代理。在`chrome`浏览器，代理数组执行时间大约为正常数组的50倍，在`firefox`浏览器大约为20倍。


## 第九章
1. 数组的方法`pop/push`和`shift/unshift`都是对数组进行更改。
- `pop/push`方法对数组的最后一项进行更改。
- `shift/unshift`方法对数组的第一项进行更改。修改第一个元素，之后的每一个元素的索引都需要更改，因此`pop/push`比`shift/unshift`要快很多。

2. `map`方法将对数组的每个元素执行传入的回调函数，并返回**一个新数组**。
3. `every`方法是数组的每一项返回`true`，则返回`true`，`some`方法是至少有一项返回`true`， 则返回`true`。


## 第十章
1. 可以使用字面量和构造函数的方式创建正则表达式
- `const reg = /test/`
- `const reg = new RegExp('test')`
2. 正则表达式提供了五种修饰符：
- `i`：不区分大小写
- `g`：查找所有匹配项，在查找到第一个匹配时不会停止，会继续查找下一个匹配。
- `u`：允许使用Unicode点转义符
- `y`：开启粘连匹配
- `m`：允许多行匹配


## 第十一章
1. 在javascript es6之前，只有两种作用域：全局作用域和函数作用域。为了编写模块化代码，不得不由开发者们自己实现响应的功能。每个模块系统至少需要以下操作：
- 定义模块接口，通过接口可以调用模块的功能
- 隐藏模块的内部实现。

2. AMD和CommonJS是两个均可以定义JavaScript模块的标准（异步加载）。
- AMD是基于浏览器的
- CommonJS是基于JavaScript环境的（Node.js）
3. AMD最流行的实现是`requre.js`。具有以下优点：
- 自动处理依赖，我们无需考虑模块的引用顺序
- 异步加载模块，避免阻塞
- 在同一个文件中可以定义多个模块
4. CommonJS在Node.js中应用最多（同步加载）。具有以下优点：
- 语法简单。只需要定义`module.exports`属性。通过`require`引入。
5. 小的、组织良好的代码远比庞大的代码更容易理解和维护。优化程序解构和组织方式的一种方式是将代码拆分成小的、耦合相对松散的片段或模块。
6. 模块是比对象或函数稍大的、用于组织代码的单元，通过模块可以将程序进行分类。
7. 通常来说，模块可以降低理解成本，模块易于维护，并可以提高代码的可重用性。


## 第十三章
1. w3c规定，一个事件的处理方式有两种：
    1. 事件捕获——首先被顶部元素捕获，并依次向下传递
    2. 事件冒泡——目标元素被捕获后，转为事件冒泡，并依次向上传递
2. 可以通过向`addEventListener`传递参数来选择事件的处理顺序。第三个参数为`true`，将采用事件捕获；为`false`，将采用事件冒泡。默认是事件冒泡。
3. 在祖先元素上代理事件：

意思是：如果一个父元素中，有一些子元素，如点击每个子元素则改变颜色，这样可以给每个子元素添加监听事件。但是这样比较繁琐，也不高效。更优雅的方法是在其**父元素或祖先元素上注册事件**，然后去改变`event.target`的颜色（需要判断一下**要处理的事件和`event.target`相同）。


## 第十四章
1. 在处理浏览器中缺失的特性时，可以使用垫片(polyfill)。polyfill是浏览器备用模式，如果浏览器不支持某一特定的功能，我们可以提供自己的实现。
2. 只要有可能，要尽量使用默认的方法来执行操作。对于没有提供的方法，我们才自己实现。例如：使用`if(!Array.prototype.find)`来判断浏览器是否支持find方法。
